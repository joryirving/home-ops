---
apiVersion: v1
kind: ConfigMap
metadata:
  name: openclaw-hooks-scripts
data:
  github-webhook-transform.js: |
    // GitHub Webhook Transform for OpenClaw
    const { spawn } = require('child_process');

    // Import the existing GitHub App token manager
    const { getTokenManager } = require('./github-app-token-manager.js');

    // Import the grumpy-sysadmin agent to execute review directly
    const { processPRReview } = require('./grumpy-sysadmin-agent.js');

    /**
     * Transform function for GitHub webhook events
     * @param {Object} ctx - Context object containing payload, headers, etc.
     * @returns {Object} Response object
     */
    async function transform(ctx) {
      const event = ctx.payload;
      console.log('Received GitHub webhook event:', event.action || 'unknown');

      const eventType = ctx.headers['x-github-event'];
      const deliveryId = ctx.headers['x-github-delivery'];

      console.log(`Processing $${eventType} event with delivery ID: $${deliveryId}`);

      if (eventType === 'pull_request' && event.action === 'opened') {
        // GitHub webhook payload structure has the PR data in 'pull_request' field
        const pullRequest = event.pull_request || event;

        // Extract PR information using proper GitHub webhook payload structure
        const prInfo = {
          repo: event.repository?.full_name || `$${event.organization?.login}/$${event.repository?.name}`,
          pr_number: pullRequest?.number || event.number,
          title: pullRequest?.title,
          description: pullRequest?.body || pullRequest?.description || '',
          author: pullRequest?.user?.login || event.sender?.login || 'unknown',
          url: pullRequest?.html_url,
          created_at: pullRequest?.created_at || pullRequest?.created_at
        };

        console.log(`New PR #$${prInfo.pr_number} opened: $${prInfo.title}`);

        // Validate that we have the required information
        if (!prInfo.repo || !prInfo.pr_number) {
          console.error('Missing required PR information:', prInfo);
          console.error('Full event object:', JSON.stringify(event, null, 2));
          return {
            message: `Error: Missing required PR information. Repo: $${prInfo.repo}, PR Number: $${prInfo.pr_number}`,
            channel: "last"
          };
        }

        try {
          // Execute the PR review directly instead of spawning an agent
          const reviewResult = await processPRReview(
            { repo: prInfo.repo, pr_number: prInfo.pr_number },
            { pr_info: prInfo }
          );

          console.log('PR review completed:', reviewResult);

          return {
            message: `Grumpy sysadmin review completed for PR #$${prInfo.pr_number}`,
            channel: "last"
          };
        } catch (error) {
          console.error('Error during PR review:', error.message);
          return {
            message: `Error during PR review: $${error.message}`,
            channel: "last"
          };
        }
      }
      else if (eventType === 'pull_request' && event.action === 'synchronize') {
        // Handle PR updates (new commits pushed)
        const pullRequest = event.pull_request || event;

        const prInfo = {
          repo: event.repository?.full_name || `$${event.organization?.login}/$${event.repository?.name}`,
          pr_number: pullRequest?.number || event.number,
          title: pullRequest?.title,
          description: pullRequest?.body || pullRequest?.description || '',
          author: pullRequest?.user?.login || event.sender?.login || 'unknown',
          url: pullRequest?.html_url,
          created_at: pullRequest?.created_at || pullRequest?.created_at
        };

        console.log(`PR #$${prInfo.pr_number} synchronized (updated): $${prInfo.title}`);

        // Validate that we have the required information
        if (!prInfo.repo || !prInfo.pr_number) {
          console.error('Missing required PR information for sync event:', prInfo);
          return {
            message: `Error: Missing required PR information for sync. Repo: $${prInfo.repo}, PR Number: $${prInfo.pr_number}`,
            channel: "last"
          };
        }

        try {
          // Execute the PR review directly for sync events too
          const reviewResult = await processPRReview(
            { repo: prInfo.repo, pr_number: prInfo.pr_number },
            { pr_info: prInfo }
          );

          console.log('PR resync review completed:', reviewResult);

          return {
            message: `Grumpy sysadmin review completed for PR #$${prInfo.pr_number} resync`,
            channel: "last"
          };
        } catch (error) {
          console.error('Error during PR resync review:', error.message);
          return {
            message: `Error during PR resync review: $${error.message}`,
            channel: "last"
          };
        }
      }
      else if (eventType === 'pull_request' && ['closed', 'merged'].includes(event.action)) {
        const pullRequest = event.pull_request || event;
        const action = event.action === 'merged' ? 'merged' : 'closed';

        console.log(`PR #$${pullRequest?.number} $${action}: $${pullRequest?.title}`);

        return {
          message: `Pull request #$${event.repository?.full_name}/$${pullRequest?.number} was $${action}`,
          channel: "last"
        };
      }
      else if (eventType === 'pull_request' && ['review_requested', 'ready_for_review'].includes(event.action)) {
        const pullRequest = event.pull_request || event;
        const action = event.action === 'review_requested' ? 'review requested' : 'ready for review';

        console.log(`PR #$${pullRequest?.number} $${action}: $${pullRequest?.title}`);

        return {
          message: `Pull request #$${event.repository?.full_name}/$${pullRequest?.number} is now $${action}`,
          channel: "last"
        };
      }
      else {
        // For other events, return a simple acknowledgment
        return {
          message: `Received $${eventType} event: $${event.action || 'unknown'}`,
          channel: "last"
        };
      }
    }

    module.exports = transform;
  github-app-token-manager.js: |
    // GitHub App Token Manager for OpenClaw
    const jwt = require('jsonwebtoken');
    const crypto = require('crypto');

    class GitHubAppTokenManager {
      constructor() {
        this.appId = process.env.GITHUB_APP_ID;
        this.installationId = process.env.GITHUB_APP_INSTALLATION_ID;
        this.privateKey = process.env.GITHUB_APP_PRIVATE_KEY?.replace(/\\n/g, '\n');

        this.currentToken = null;
        this.tokenExpiration = null;
        this.refreshTimer = null;
        this.initialized = false;
        this.initializationPromise = null;

        if (!this.appId || !this.installationId || !this.privateKey) {
          throw new Error('Missing required GitHub App environment variables');
        }
      }

      async initialize() {
        if (this.initialized) {
          return;
        }

        if (this.initializationPromise) {
          // If we're already initializing, wait for that to complete
          return await this.initializationPromise;
        }

        // Start initialization
        this.initializationPromise = this._performInitialization();
        await this.initializationPromise;
        this.initialized = true;
      }

      async _performInitialization() {
        await this.generateToken();
        this.scheduleRefresh();
      }

      generateJWT() {
        const now = Math.floor(Date.now() / 1000);
        const payload = {
          iat: now,
          exp: now + (10 * 60), // 10 minutes
          iss: this.appId
        };

        return jwt.sign(payload, this.privateKey, { algorithm: 'RS256' });
      }

      async generateToken() {
        try {
          const jwtToken = this.generateJWT();

          const response = await fetch('https://api.github.com/app/installations/' + this.installationId + '/access_tokens', {
            method: 'POST',
            headers: {
              'Authorization': 'Bearer ' + jwtToken,
              'Accept': 'application/vnd.github.v3+json',
              'User-Agent': 'OpenClaw-GitHub-App'
            }
          });

          if (!response.ok) {
            throw new Error('Failed to get installation token: ' + response.status + ' - ' + await response.text());
          }

          const data = await response.json();
          this.currentToken = data.token;
          // Set expiration 5 minutes before actual expiration for safety buffer
          this.tokenExpiration = new Date(data.expires_at).getTime() - (5 * 60 * 1000);

          console.log('GitHub App token refreshed successfully');
        } catch (error) {
          console.error('Error generating GitHub App token:', error.message);
          throw error;
        }
      }

      scheduleRefresh() {
        // Clear existing timer if any
        if (this.refreshTimer) {
          clearTimeout(this.refreshTimer);
        }

        // Calculate time until refresh (5 minutes before expiration)
        const now = Date.now();
        let timeUntilRefresh = (this.tokenExpiration - now);

        // Ensure we don't have negative time
        if (timeUntilRefresh <= 0) {
          timeUntilRefresh = 60000; // Refresh in 1 minute if already expired
        } else if (timeUntilRefresh > 55 * 60 * 1000) { // More than 55 mins
          timeUntilRefresh = 55 * 60 * 1000; // Max refresh in 55 mins
        }

        console.log('Scheduling next token refresh in ' + Math.round(timeUntilRefresh / 1000) + ' seconds');

        this.refreshTimer = setTimeout(async () => {
          try {
            await this.generateToken();
            this.scheduleRefresh(); // Schedule next refresh
          } catch (error) {
            console.error('Failed to refresh token, retrying in 1 minute:', error.message);
            // Retry in 1 minute if failed
            this.refreshTimer = setTimeout(() => {
              this.scheduleRefresh();
            }, 60000);
          }
        }, timeUntilRefresh);
      }

      async getToken() {
        // Wait for initialization if needed
        if (!this.initialized && this.initializationPromise) {
          await this.initializationPromise;
        } else if (!this.initialized) {
          await this.initialize();
        }

        if (!this.currentToken) {
          throw new Error('No valid GitHub App token available');
        }

        // Check if token is expired
        if (Date.now() >= this.tokenExpiration) {
          // Token is expired, generate a new one
          await this.generateToken();
        }

        return this.currentToken;
      }

      // Method to get token info for debugging
      getTokenInfo() {
        return {
          initialized: this.initialized,
          hasToken: !!this.currentToken,
          expiresIn: this.tokenExpiration ? (this.tokenExpiration - Date.now()) / 1000 : 0,
          expiration: this.tokenExpiration ? new Date(this.tokenExpiration) : null
        };
      }
    }

    // Export singleton instance
    let tokenManager = null;

    async function getTokenManager() {
      if (!tokenManager) {
        tokenManager = new GitHubAppTokenManager();
        await tokenManager.initialize();
      }
      return tokenManager;
    }

    module.exports = { getTokenManager, GitHubAppTokenManager };
  grumpy-sysadmin-agent.js: |
    // Grumpy Sysadmin Agent for GitHub PR Reviews
    const { spawn } = require('child_process');

    // Import the GitHub App token manager
    const { getTokenManager } = require('./github-app-token-manager.js');

    /**
     * Process a pull request review request
     * @param {Object} context - The context containing PR information
     * @param {Object} metadata - Metadata from the webhook
     */
    async function processPRReview(context, metadata) {
      console.log('Grumpy Sysadmin Agent: Processing PR review request');

      // Extract PR information from context or metadata
      const prInfo = metadata?.pr_info || {};
      const repo = prInfo.repo || context.repo;
      const prNumber = prInfo.pr_number || context.pr_number;

      if (!repo || !prNumber) {
        console.error('Missing required PR information:', { repo, prNumber, prInfo, metadata });
        return 'Error: Missing required PR information for review';
      }

      console.log(`Reviewing PR #$${prNumber} in $${repo}`);

      try {
        // Get the token manager and token for GitHub API access
        const tokenManager = await getTokenManager();
        const githubToken = await tokenManager.getToken();

        // Fetch the PR details from GitHub API
        const prResponse = await fetch(`https://api.github.com/repos/$${repo}/pulls/$${prNumber}`, {
          headers: {
            'Authorization': `Bearer $${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'OpenClaw-GitHub-App'
          }
        });

        if (!prResponse.ok) {
          throw new Error(`Failed to fetch PR: $${prResponse.status} - $${await prResponse.text()}`);
        }

        const prDetails = await prResponse.json();

        // Fetch the PR files to analyze changes
        const filesResponse = await fetch(`https://api.github.com/repos/$${repo}/pulls/$${prNumber}/files`, {
          headers: {
            'Authorization': `Bearer $${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'OpenClaw-GitHub-App'
          }
        });

        if (!filesResponse.ok) {
          console.warn('Could not fetch PR files:', await filesResponse.text());
        }

        const files = filesResponse.ok ? await filesResponse.json() : [];

        // Perform grumpy sysadmin review
        const reviewComment = generateGrumpyReview(prDetails, files);

        // Post the review comment to the PR
        const commentResponse = await fetch(`https://api.github.com/repos/$${repo}/issues/$${prNumber}/comments`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer $${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'OpenClaw-GitHub-App',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            body: reviewComment
          })
        });

        if (!commentResponse.ok) {
          throw new Error(`Failed to post review comment: $${commentResponse.status} - $${await commentResponse.text()}`);
        }

        console.log(`Successfully posted review to PR #$${prNumber}`);

        return `Grumpy Sysadmin Agent: Successfully posted review to PR #$${prNumber} in $${repo}`;

      } catch (error) {
        console.error('Error in PR review process:', error.message);
        return `Error posting PR review: $${error.message}`;
      }
    }

    /**
     * Generate a grumpy sysadmin-style review based on PR details
     * @param {Object} prDetails - The PR details from GitHub API
     * @param {Array} files - Array of files changed in the PR
     * @returns {string} The review comment
     */
    function generateGrumpyReview(prDetails, files) {
      const { title, user, created_at, body, html_url } = prDetails;
      const fileCount = files.length;
      const additions = files.reduce((sum, file) => sum + (file.additions || 0), 0);
      const deletions = files.reduce((sum, file) => sum + (file.deletions || 0), 0);

      // Generate a grumpy but constructive review
      let review = `## ‚ö†Ô∏è Grumpy Sysadmin Review for PR #$${prDetails.number}

    Hello @$${user.login},

    As your resident grumpy sysadmin, I've reviewed your pull request "$${title}". Here are my observations:

    ### üìã Summary
    - **Author**: @$${user.login}
    - **Created**: $${created_at}
    - **Files Changed**: $${fileCount}
    - **Additions**: $${additions}
    - **Deletions**: $${deletions}

    ### üîç Technical Assessment
    `;

      // Add some grumpy but helpful commentary based on the changes
      if (fileCount > 10) {
        review += `- **‚ö†Ô∏è Large PR**: This PR touches $${fileCount} files. Could this be broken down into smaller, more focused changes?\n`;
      }

      if (additions > 200) {
        review += `- **‚ö†Ô∏è Code Volume**: This PR adds $${additions} lines. Please ensure adequate testing.\n`;
      }

      if (!body || body.trim().length < 20) {
        review += `- **‚ö†Ô∏è Description**: The PR description is quite brief. Please provide more context about *why* these changes are needed.\n`;
      }

      // Check for common infrastructure files that might need special attention
      const sensitiveFiles = files.filter(file =>
        file.filename.includes('k8s') ||
        file.filename.includes('yaml') ||
        file.filename.includes('yml') ||
        file.filename.includes('config') ||
        file.filename.includes('secret')
      );

      if (sensitiveFiles.length > 0) {
        review += `- **üö® Sensitive Areas**: This PR touches infrastructure/configuration files ($${sensitiveFiles.map(f => f.filename).join(', ')}). Extra scrutiny required!\n`;
      }

      // If no specific issues found, add general grumpiness
      if (review.split('\n').filter(line => line.startsWith('-')).length === 0) {
        review += `- **üîç General**: Changes look reasonable, but please ensure all tests pass and consider edge cases.\n`;
      }

      review += `
    ### ‚úÖ Approval Criteria
    Before this PR can be merged, please ensure:

    1. All CI checks are passing
    2. Changes have been tested in a staging environment
    3. Documentation has been updated if applicable
    4. Another team member has reviewed this code

    ### üìù Final Thoughts
    Thanks for your contribution to the infrastructure. Remember: "With great power comes great responsibility." Please make sure you understand the implications of these changes before merging.

    Yours grumpily,
    The Grumpy Sysadmin ü§ñ

    *This review was automatically generated by the Grumpy Sysadmin Agent.*
    `;

      return review;
    }

    /**
     * Main function to handle the agent task
     * @param {Object} context - The context object
     * @param {Object} options - Additional options
     */
    async function handleAgentTask(context, options = {}) {
      try {
        console.log('Grumpy Sysadmin Agent activated');

        // Check if this is a PR review request
        if (context.message &&
            (context.message.toLowerCase().includes('review') ||
             context.message.toLowerCase().includes('pull request') ||
             context.metadata?.pr_number)) {

          return await processPRReview(context, context.metadata);
        }

        // Default response for other requests
        return "Grumpy Sysadmin Agent: I specialize in reviewing pull requests. Please provide PR details for review.";

      } catch (error) {
        console.error('Grumpy Sysadmin Agent error:', error.message);
        return `Grumpy Sysadmin Agent Error: $${error.message}`;
      }
    }

    module.exports = { handleAgentTask, processPRReview, generateGrumpyReview };
