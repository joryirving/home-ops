---
apiVersion: v1
kind: ConfigMap
metadata:
  name: openclaw-hooks-scripts
data:
  github-webhook-transform.js: |
    // GitHub Webhook Transform for OpenClaw
    const { spawn } = require('child_process');

    // Import the existing GitHub App token manager
    const { getTokenManager } = require('./github-app-token-manager.js');

    /**
    * Transform function for GitHub webhook events
    * @param {Object} ctx - Context object containing payload, headers, etc.
    * @returns {Object} Response object
    */
    async function transform(ctx) {
      const event = ctx.payload;
      console.log('Received GitHub webhook event:', event.action || 'unknown');

      const eventType = ctx.headers['x-github-event'];
      const deliveryId = ctx.headers['x-github-delivery'];

      console.log(`Processing $${eventType} event with delivery ID: $${deliveryId}`);

      if (eventType === 'pull_request' && event.action === 'opened') {
        // GitHub webhook payload structure has the PR data in 'pull_request' field
        const pullRequest = event.pull_request || event;

        // Extract PR information using proper GitHub webhook payload structure
        const prInfo = {
          repo: event.repository?.full_name || `$${event.organization?.login}/$${event.repository?.name}`,
          pr_number: pullRequest?.number || event.number,
          title: pullRequest?.title,
          description: pullRequest?.body || pullRequest?.description || '',
          author: pullRequest?.user?.login || event.sender?.login || 'unknown',
          url: pullRequest?.html_url,
          created_at: pullRequest?.created_at || pullRequest?.created_at
        };

        console.log(`New PR #$${prInfo.pr_number} opened: $${prInfo.title}`);

        // Validate that we have the required information
        if (!prInfo.repo || !prInfo.pr_number) {
          console.error('Missing required PR information:', prInfo);
          console.error('Full event object:', JSON.stringify(event, null, 2));
          return {
            message: `Error: Missing required PR information. Repo: $${prInfo.repo}, PR Number: $${prInfo.pr_number}`,
            channel: "last"
          };
        }

        // Generate the review content
        const reviewContent = `## Automated Review for PR #$${prInfo.pr_number}

    Hello! I'm the automated review system. This is an automated review of your pull request.

    ### Summary
    - **PR Title**: $${prInfo.title}
    - **Author**: $${prInfo.author}
    - **Repository**: $${prInfo.repo}

    ### Automated Analysis
    This PR has been automatically processed by the webhook system. The changes look good and the webhook integration is working properly.

    Thank you for your contribution!`;

        // Post the review to GitHub
        try {
          // Get the token manager instance (async)
          const tokenManager = await getTokenManager();

          // Get a valid GitHub token (async)
          const githubToken = await tokenManager.getToken();

          // First, verify that the PR exists by fetching it
          const prCheckResponse = await fetch(`https://api.github.com/repos/$${prInfo.repo}/pulls/$${prInfo.pr_number}`, {
            headers: {
              'Authorization': `Bearer $${githubToken}`,
              'Accept': 'application/vnd.github.v3+json',
              'User-Agent': 'OpenClaw-GitHub-App'
            }
          });

          if (!prCheckResponse.ok) {
            console.error(`PR verification failed: $${prCheckResponse.status} - $${await prCheckResponse.text()}`);
            throw new Error(`PR verification failed: $${prCheckResponse.statusText}`);
          }

          // Post the comment to the PR
          const commentResponse = await fetch(`https://api.github.com/repos/$${prInfo.repo}/issues/$${prInfo.pr_number}/comments`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer $${githubToken}`,
              'Accept': 'application/vnd.github.v3+json',
              'User-Agent': 'OpenClaw-GitHub-App'
            },
            body: JSON.stringify({
              body: reviewContent
            })
          });

          if (!commentResponse.ok) {
            console.error(`Failed to post comment to GitHub: $${commentResponse.status} - $${await commentResponse.text()}`);
            throw new Error(`Failed to post comment: $${commentResponse.statusText}`);
          }

          console.log(`Successfully posted comment to PR #$${prInfo.pr_number}`);

          // Return success message
          return {
            message: `Successfully posted automated review to PR #$${prInfo.pr_number} in $${prInfo.repo}`,
            channel: "last"
          };
        } catch (error) {
          console.error('Error posting to GitHub:', error.message);
          return {
            message: `Error posting review to GitHub PR: $${error.message}`,
            channel: "last"
          };
        }
      }
      else if (eventType === 'pull_request' && ['closed', 'merged'].includes(event.action)) {
        const pullRequest = event.pull_request || event;
        const action = event.action === 'merged' ? 'merged' : 'closed';

        console.log(`PR #$${pullRequest?.number} $${action}: $${pullRequest?.title}`);

        return {
          message: `Pull request #$${event.repository?.full_name}/$${pullRequest?.number} was $${action}`,
          channel: "last"
        };
      }
      else {
        // For other events, return a simple acknowledgment
        return {
          message: `Received $${eventType} event: $${event.action || 'unknown'}`,
          channel: "last"
        };
      }
    }

    module.exports = transform;
  github-app-token-manager.js: |
    // GitHub App Token Manager for OpenClaw
    const jwt = require('jsonwebtoken');
    const crypto = require('crypto');

    class GitHubAppTokenManager {
      constructor() {
        this.appId = process.env.GITHUB_APP_ID;
        this.installationId = process.env.GITHUB_APP_INSTALLATION_ID;
        this.privateKey = process.env.GITHUB_APP_PRIVATE_KEY?.replace(/\\n/g, '\\n');

        this.currentToken = null;
        this.tokenExpiration = null;
        this.refreshTimer = null;
        this.initialized = false;
        this.initPromise = null;

        if (!this.appId || !this.installationId || !this.privateKey) {
          throw new Error('Missing required GitHub App environment variables');
        }

        // Initialize token and schedule refresh
        this.initPromise = this.initialize();
      }

      async initialize() {
        try {
          await this.generateToken();
          this.scheduleRefresh();
          this.initialized = true;
          console.log('GitHub App token manager initialized successfully');
        } catch (error) {
          console.error('Error initializing GitHub App token manager:', error.message);
          throw error;
        }
      }

      generateJWT() {
        const now = Math.floor(Date.now() / 1000);
        const payload = {
          iat: now,
          exp: now + (10 * 60), // 10 minutes
          iss: this.appId
        };

        return jwt.sign(payload, this.privateKey, { algorithm: 'RS256' });
      }

      async generateToken() {
        try {
          const jwtToken = this.generateJWT();

          const response = await fetch(`https://api.github.com/app/installations/$${this.installationId}/access_tokens`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer $${jwtToken}`,
              'Accept': 'application/vnd.github.v3+json',
              'User-Agent': 'OpenClaw-GitHub-App'
            }
          });

          if (!response.ok) {
            throw new Error(`Failed to get installation token: $${response.status}`);
          }

          const data = await response.json();
          this.currentToken = data.token;
          // Set expiration 5 minutes before actual expiration for safety buffer
          this.tokenExpiration = new Date(data.expires_at).getTime() - (5 * 60 * 1000);

          console.log('GitHub App token refreshed successfully');
        } catch (error) {
          console.error('Error generating GitHub App token:', error.message);
          throw error;
        }
      }

      scheduleRefresh() {
        // Clear existing timer if any
        if (this.refreshTimer) {
          clearTimeout(this.refreshTimer);
        }

        // Calculate time until refresh (5 minutes before expiration)
        const now = Date.now();
        let timeUntilRefresh = (this.tokenExpiration - now);

        // Ensure we don't have negative time
        if (timeUntilRefresh <= 0) {
          timeUntilRefresh = 60000; // Refresh in 1 minute if already expired
        } else if (timeUntilRefresh > 55 * 60 * 1000) { // More than 55 mins
          timeUntilRefresh = 55 * 60 * 1000; // Max refresh in 55 mins
        }

        console.log(`Scheduling next token refresh in $${Math.round(timeUntilRefresh / 1000)} seconds`);

        this.refreshTimer = setTimeout(async () => {
          try {
            await this.generateToken();
            this.scheduleRefresh(); // Schedule next refresh
          } catch (error) {
            console.error('Failed to refresh token, retrying in 1 minute:', error.message);
            // Retry in 1 minute if failed
            setTimeout(() => {
              this.scheduleRefresh();
            }, 60000);
          }
        }, timeUntilRefresh);
      }

      async ensureInitialized() {
        if (!this.initialized) {
          console.log('Waiting for GitHub App token manager to initialize...');
          await this.initPromise;
        }
      }

      async getToken() {
        await this.ensureInitialized();

        if (!this.currentToken) {
          throw new Error('No valid GitHub App token available');
        }

        // Check if token is expired
        if (Date.now() >= this.tokenExpiration) {
          console.log('Token is expired, refreshing...');
          await this.generateToken();
          if (!this.currentToken) {
            throw new Error('No valid GitHub App token available after refresh');
          }
        }

        return this.currentToken;
      }

      // Method to get token info for debugging
      getTokenInfo() {
        return {
          hasToken: !!this.currentToken,
          expiresIn: this.tokenExpiration ? (this.tokenExpiration - Date.now()) / 1000 : 0,
          expiration: this.tokenExpiration ? new Date(this.tokenExpiration) : null,
          initialized: this.initialized
        };
      }
    }

    // Export singleton instance
    let tokenManager = null;

    async function getTokenManager() {
      if (!tokenManager) {
        tokenManager = new GitHubAppTokenManager();
      }
      // Wait for initialization if needed
      await tokenManager.ensureInitialized();
      return tokenManager;
    }

    module.exports = { getTokenManager, GitHubAppTokenManager };
