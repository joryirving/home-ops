---
apiVersion: v1
kind: ConfigMap
metadata:
  name: openclaw-hooks-scripts
data:
  github-webhook-transform.js: |-
    // GitHub Webhook Transform for OpenClaw - Robust Version
    const { spawn } = require('child_process');

    // Import the existing GitHub App token manager
    const { getTokenManager } = require('./github-app-token-manager.js');

    // Import the grumpy-sysadmin agent to execute review directly
    const { processPRReview } = require('./grumpy-sysadmin-agent.js');

    /**
     * Transform function for GitHub webhook events
     * Robustly handles both simplified payloads from webhook receiver and full GitHub payloads
     * @param {Object} ctx - Context object containing payload, headers, etc.
     * @returns {Object} Response object
     */
    async function transform(ctx) {
      const event = ctx.payload || {};
      const headers = ctx.headers || {};

      // Try to determine the event type from multiple sources
      let eventType = headers['x-github-event'] || event.action || 'unknown';

      // Also check for other potential event indicators
      if (event.hasOwnProperty('pull_request') && event.pull_request) {
        eventType = 'pull_request';
      } else if (event.hasOwnProperty('issue') && event.issue) {
        eventType = 'issue';
      } else if (event.hasOwnProperty('repository') && event.repository) {
        eventType = 'repository';
      }

      // Extract action from various possible locations
      let action = 'unknown';
      if (event.action) {
        action = event.action;
      } else if (event.delivery_id && event.delivery_id.startsWith('test-delivery')) {
        // This is likely from our webhook receiver with artificial delivery ID
        action = event.payload?.action || 'unknown';
      }

      // Log incoming event for debugging
      console.log('Received GitHub webhook event:', {
        eventType,
        action,
        has_pull_request: !!event.pull_request,
        has_repository: !!event.repository,
        delivery_id: event.delivery_id,
        headers_present: Object.keys(headers)
      });

      // Extract information with fallbacks
      const repo = event.repository?.full_name ||
                  (event.pull_request?.html_url ?
                    event.pull_request.html_url.split('/')[3] + '/' + event.pull_request.html_url.split('/')[4] :
                    'unknown/unknown');

      const prNumber = event.pull_request?.number ||
                      (event.issue?.pull_request ?
                        parseInt(event.issue.url.split('/').pop()) :
                        null);

      // Handle different event types based on the payload
      if (repo !== 'unknown/unknown' && prNumber && action !== 'unknown') {
        // This looks like a pull request event

        const prInfo = {
          repo: repo,
          pr_number: prNumber,
          title: event.pull_request?.title || event.issue?.title || 'Unknown Title',
          description: event.pull_request?.body || event.issue?.body || '',
          author: event.pull_request?.user?.login || event.repository?.owner?.login || 'unknown',
          url: event.pull_request?.html_url || event.issue?.html_url,
          created_at: event.pull_request?.created_at || event.issue?.created_at
        };

        console.log('Processing PR #' + prInfo.pr_number + ' in ' + prInfo.repo + ' with action: ' + action);

        if (action === 'opened' || action === 'synchronize') {
          try {
            // Execute the PR review directly instead of spawning an agent
            const reviewResult = await processPRReview(
              { repo: prInfo.repo, pr_number: prInfo.pr_number },
              { pr_info: prInfo }
            );

            console.log('PR review completed:', reviewResult);

            return {
              message: 'Grumpy sysadmin review completed for PR #' + prInfo.pr_number,
              channel: "last"
            };
          } catch (error) {
            console.error('Error during PR review:', error.message);
            return {
              message: 'Error during PR review: ' + error.message,
              channel: "last"
            };
          }
        }
        else if (['closed', 'merged'].includes(action)) {
          console.log('PR #' + prInfo.pr_number + ' ' + action + ': ' + prInfo.title);

          return {
            message: 'Pull request #' + prInfo.repo + '/' + prInfo.pr_number + ' was ' + action,
            channel: "last"
          };
        }
        else {
          // For other PR actions
          return {
            message: 'Received pull request event for PR #' + prInfo.pr_number + ': ' + action,
            channel: "last"
          };
        }
      }
      else {
        // Handle other event types or return a default response
        console.log('Received non-PR event or incomplete event:', { action, repo, prNumber });

        // If it's a test delivery from our webhook receiver, try to extract from nested payload
        if (event.delivery_id && event.delivery_id.startsWith('test-delivery') && event.payload) {
          const nestedEvent = event.payload;
          const nestedAction = nestedEvent.action || 'unknown';
          const nestedRepo = nestedEvent.repository?.full_name || 'unknown/unknown';
          const nestedPrNumber = nestedEvent.pull_request?.number || null;

          if (nestedRepo !== 'unknown/unknown' && nestedPrNumber) {
            if (nestedAction === 'opened' || nestedAction === 'synchronize') {
              try {
                const reviewResult = await processPRReview(
                  { repo: nestedRepo, pr_number: nestedPrNumber },
                  { pr_info: {
                    repo: nestedRepo,
                    pr_number: nestedPrNumber,
                    title: nestedEvent.pull_request?.title || 'Unknown Title',
                    description: nestedEvent.pull_request?.body || '',
                    author: nestedEvent.pull_request?.user?.login || 'unknown',
                    url: nestedEvent.pull_request?.html_url,
                    created_at: nestedEvent.pull_request?.created_at
                  }}
                );

                return {
                  message: 'Grumpy sysadmin review completed for PR #' + nestedPrNumber,
                  channel: "last"
                };
              } catch (error) {
                return {
                  message: 'Error during PR review: ' + error.message,
                  channel: "last"
                };
              }
            }
          }
        }

        return {
          message: 'Received webhook event with action: ' + action,
          channel: "last"
        };
      }
    }

    module.exports = transform;
  github-app-token-manager.js: |
    // GitHub App Token Manager for OpenClaw
    const jwt = require('jsonwebtoken');
    const crypto = require('crypto');

    class GitHubAppTokenManager {
      constructor() {
        this.appId = process.env.GITHUB_APP_ID;
        this.installationId = process.env.GITHUB_APP_INSTALLATION_ID;
        this.privateKey = process.env.GITHUB_APP_PRIVATE_KEY?.replace(/\\n/g, '\n');

        this.currentToken = null;
        this.tokenExpiration = null;
        this.refreshTimer = null;
        this.initialized = false;
        this.initializationPromise = null;

        if (!this.appId || !this.installationId || !this.privateKey) {
          throw new Error('Missing required GitHub App environment variables');
        }
      }

      async initialize() {
        if (this.initialized) {
          return;
        }

        if (this.initializationPromise) {
          // If we're already initializing, wait for that to complete
          return await this.initializationPromise;
        }

        // Start initialization
        this.initializationPromise = this._performInitialization();
        await this.initializationPromise;
        this.initialized = true;
      }

      async _performInitialization() {
        await this.generateToken();
        this.scheduleRefresh();
      }

      generateJWT() {
        const now = Math.floor(Date.now() / 1000);
        const payload = {
          iat: now,
          exp: now + (10 * 60), // 10 minutes
          iss: this.appId
        };

        return jwt.sign(payload, this.privateKey, { algorithm: 'RS256' });
      }

      async generateToken() {
        try {
          const jwtToken = this.generateJWT();

          const response = await fetch('https://api.github.com/app/installations/' + this.installationId + '/access_tokens', {
            method: 'POST',
            headers: {
              'Authorization': 'Bearer ' + jwtToken,
              'Accept': 'application/vnd.github.v3+json',
              'User-Agent': 'OpenClaw-GitHub-App'
            }
          });

          if (!response.ok) {
            throw new Error('Failed to get installation token: ' + response.status + ' - ' + await response.text());
          }

          const data = await response.json();
          this.currentToken = data.token;
          // Set expiration 5 minutes before actual expiration for safety buffer
          this.tokenExpiration = new Date(data.expires_at).getTime() - (5 * 60 * 1000);

          console.log('GitHub App token refreshed successfully');
        } catch (error) {
          console.error('Error generating GitHub App token:', error.message);
          throw error;
        }
      }

      scheduleRefresh() {
        // Clear existing timer if any
        if (this.refreshTimer) {
          clearTimeout(this.refreshTimer);
        }

        // Calculate time until refresh (5 minutes before expiration)
        const now = Date.now();
        let timeUntilRefresh = (this.tokenExpiration - now);

        // Ensure we don't have negative time
        if (timeUntilRefresh <= 0) {
          timeUntilRefresh = 60000; // Refresh in 1 minute if already expired
        } else if (timeUntilRefresh > 55 * 60 * 1000) { // More than 55 mins
          timeUntilRefresh = 55 * 60 * 1000; // Max refresh in 55 mins
        }

        console.log('Scheduling next token refresh in ' + Math.round(timeUntilRefresh / 1000) + ' seconds');

        this.refreshTimer = setTimeout(async () => {
          try {
            await this.generateToken();
            this.scheduleRefresh(); // Schedule next refresh
          } catch (error) {
            console.error('Failed to refresh token, retrying in 1 minute:', error.message);
            // Retry in 1 minute if failed
            this.refreshTimer = setTimeout(() => {
              this.scheduleRefresh();
            }, 60000);
          }
        }, timeUntilRefresh);
      }

      async getToken() {
        // Wait for initialization if needed
        if (!this.initialized && this.initializationPromise) {
          await this.initializationPromise;
        } else if (!this.initialized) {
          await this.initialize();
        }

        if (!this.currentToken) {
          throw new Error('No valid GitHub App token available');
        }

        // Check if token is expired
        if (Date.now() >= this.tokenExpiration) {
          // Token is expired, generate a new one
          await this.generateToken();
        }

        return this.currentToken;
      }

      // Method to get token info for debugging
      getTokenInfo() {
        return {
          initialized: this.initialized,
          hasToken: !!this.currentToken,
          expiresIn: this.tokenExpiration ? (this.tokenExpiration - Date.now()) / 1000 : 0,
          expiration: this.tokenExpiration ? new Date(this.tokenExpiration) : null
        };
      }
    }

    // Export singleton instance
    let tokenManager = null;

    async function getTokenManager() {
      if (!tokenManager) {
        tokenManager = new GitHubAppTokenManager();
        await tokenManager.initialize();
      }
      return tokenManager;
    }

    module.exports = { getTokenManager, GitHubAppTokenManager };
  grumpy-sysadmin-agent.js: |
    // Grumpy Sysadmin Agent for GitHub PR Reviews
    const { spawn } = require('child_process');

    // Import the GitHub App token manager
    const { getTokenManager } = require('./github-app-token-manager.js');

    /**
     * Process a pull request review request
     * @param {Object} context - The context containing PR information
     * @param {Object} metadata - Metadata from the webhook
     */
    async function processPRReview(context, metadata) {
      console.log('Grumpy Sysadmin Agent: Processing PR review request');

      // Extract PR information from context or metadata
      const prInfo = metadata?.pr_info || {};
      const repo = prInfo.repo || context.repo;
      const prNumber = prInfo.pr_number || context.pr_number;

      if (!repo || !prNumber) {
        console.error('Missing required PR information:', { repo, prNumber, prInfo, metadata });
        return 'Error: Missing required PR information for review';
      }

      console.log(`Reviewing PR #$${prNumber} in $${repo}`);

      try {
        // Get the token manager and token for GitHub API access
        const tokenManager = await getTokenManager();
        const githubToken = await tokenManager.getToken();

        // Fetch the PR details from GitHub API
        const prResponse = await fetch(`https://api.github.com/repos/$${repo}/pulls/$${prNumber}`, {
          headers: {
            'Authorization': `Bearer $${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'OpenClaw-GitHub-App'
          }
        });

        if (!prResponse.ok) {
          throw new Error(`Failed to fetch PR: $${prResponse.status} - $${await prResponse.text()}`);
        }

        const prDetails = await prResponse.json();

        // Fetch the PR files to analyze changes
        const filesResponse = await fetch(`https://api.github.com/repos/$${repo}/pulls/$${prNumber}/files`, {
          headers: {
            'Authorization': `Bearer $${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'OpenClaw-GitHub-App'
          }
        });

        if (!filesResponse.ok) {
          console.warn('Could not fetch PR files:', await filesResponse.text());
        }

        const files = filesResponse.ok ? await filesResponse.json() : [];

        // Perform grumpy sysadmin review
        const reviewComment = await generateGrumpyReview(prDetails, files);

        // First, check if we've already commented on this PR to avoid duplicate comments
        const existingCommentsResponse = await fetch(`https://api.github.com/repos/$${repo}/issues/$${prNumber}/comments`, {
          headers: {
            'Authorization': `Bearer $${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'OpenClaw-GitHub-App'
          }
        });

        let commentResponse;
        if (existingCommentsResponse.ok) {
          const existingComments = await existingCommentsResponse.json();
          // Look for a previous comment from this bot
          const botComment = existingComments.find(comment =>
            comment.user.type === 'Bot' &&
            comment.body.includes('Grumpy Sysadmin Agent') &&
            comment.body.includes('automatically generated')
          );

          if (botComment) {
            // Update the existing comment instead of creating a new one
            commentResponse = await fetch(`https://api.github.com/repos/$${repo}/issues/comments/$${botComment.id}`, {
              method: 'PATCH',
              headers: {
                'Authorization': `Bearer $${githubToken}`,
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'OpenClaw-GitHub-App',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                body: reviewComment
              })
            });
            console.log(`Successfully updated existing review comment #$${botComment.id} for PR #$${prNumber}`);
          } else {
            // Create a new comment as before
            commentResponse = await fetch(`https://api.github.com/repos/$${repo}/issues/$${prNumber}/comments`, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer $${githubToken}`,
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'OpenClaw-GitHub-App',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                body: reviewComment
              })
            });
            console.log(`Successfully posted new review to PR #$${prNumber}`);
          }
        } else {
          // If we can't fetch existing comments, fall back to creating a new comment
          commentResponse = await fetch(`https://api.github.com/repos/$${repo}/issues/$${prNumber}/comments`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer $${githubToken}`,
              'Accept': 'application/vnd.github.v3+json',
              'User-Agent': 'OpenClaw-GitHub-App',
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              body: reviewComment
            })
          });
          console.log(`Successfully posted new review to PR #$${prNumber} (couldn't check for existing comments)`);
        }

        if (!commentResponse.ok) {
          throw new Error(`Failed to post/update review comment: $${commentResponse.status} - $${await commentResponse.text()}`);
        }

        return `Grumpy Sysadmin Agent: Successfully $${botComment ? 'updated' : 'posted'} review to PR #$${prNumber} in $${repo}`;

      } catch (error) {
        console.error('Error in PR review process:', error.message);
        return `Error posting PR review: $${error.message}`;
      }
    }

    /**
     * Generate a grumpy sysadmin-style review based on PR details using AI
     * @param {Object} prDetails - The PR details from GitHub API
     * @param {Array} files - Array of files changed in the PR
     * @returns {string} The AI-generated review comment with grumpy personality
     */
    async function generateGrumpyReview(prDetails, files) {
      const { title, user, created_at, body, html_url, number: prNumber } = prDetails;
      const fileCount = files.length;
      const additions = files.reduce((sum, file) => sum + (file.additions || 0), 0);
      const deletions = files.reduce((sum, file) => sum + (file.deletions || 0), 0);

      // Prepare a concise summary of changes with actual code diffs
      const fileSummaries = files.slice(0, 10).map(file => ({
        filename: file.filename,
        status: file.status,
        additions: file.additions,
        deletions: file.deletions,
        changes: file.patch ? file.patch.substring(0, 3000) + (file.patch.length > 3000 ? '...' : '') : null  // Increased to 3000 chars for more detail
      }));

      // Create a detailed prompt that emphasizes code analysis and grumpy sysadmin personality
      const aiPrompt = `You are an extremely grumpy, old-school Unix sysadmin who has been managing production infrastructure for 25 years.
    You've seen countless disasters caused by careless developers and you take ZERO nonsense.
    Your personality traits:
    - Sarcastically gruff and impatient
    - Speaks in gruff, direct statements
    - Cynical about "modern dev practices"
    - Obsessed with uptime, security, and "back in my day" stories
    - Takes personal offense at poor security practices
    - Uses phrases like "Listen here, kid", "Back in my day", "What could go wrong?", "I hope you have backups", "Are you kidding me?", "This is why we can't have nice things"
    - Gets genuinely angry about hardcoded passwords, missing error handling, and insecure defaults

    Analyze this pull request #$${prNumber}: "$${title}" by @$${user.login}.

    PR Details:
    - Created: $${created_at}
    - Description: $${body || 'No description provided (typical...)'}
    - Files Changed: $${fileCount}
    - Additions: $${additions}, Deletions: $${deletions}

    CRITICAL: Focus on analyzing the actual code changes in the file diffs below. Don't just comment on metadata - look at the actual code and provide specific feedback.

    File Changes (first 10 files with actual code diffs):
    $${JSON.stringify(fileSummaries, null, 2)}

    Based on the actual code changes, provide a review that:
    - Identifies specific security vulnerabilities in the code
    - Points out potential runtime errors or bugs
    - Comments on code quality, maintainability, and best practices
    - Highlights any hardcoded credentials, passwords, or secrets
    - Mentions potential performance issues
    - Calls out missing error handling or logging
    - Provides specific suggestions for improvement based on the actual code
    - Shows your grumpy personality throughout with varied expressions of frustration
    - Varies your conclusion based on what you find in the code (not repetitive boilerplate)

    Make the review feel personalized and specific to the actual code changes. Don't use repetitive sign-off phrases. Instead, end with something that reflects what you found in the code review.`;

      try {
        // Send to OpenClaw's AI interface
        const aiResponse = await fetch('http://localhost:3000/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer $${process.env.CLAWDBOT_GATEWAY_TOKEN}`
          },
          body: JSON.stringify({
            message: aiPrompt,
            thinking: 'high',
            model: 'gemini' // or whatever model you prefer for personality
          })
        });

        if (!aiResponse.ok) {
          throw new Error(`AI service responded with status: $${aiResponse.status}`);
        }

        const aiData = await aiResponse.json();
        const aiReview = aiData.response || aiData.message || "AI review generation failed";

        // Format with consistent grumpy personality
        return `## âš ï¸ Grumpy Sysadmin Review for PR #$${prNumber}

    $${aiReview}

    ---
    *This review was automatically generated by the Grumpy Sysadmin Agent.*
    *Sent from my terminal while monitoring production at 3 AM on a Sunday.*
    `;
      } catch (error) {
        console.error('AI review generation failed:', error.message);

        // Fallback with strong grumpy personality that focuses on code analysis
        return generateGrumpyReviewFallbackWithCodeAnalysis(prDetails, files);
      }
    }

    /**
     * Fallback function with strong grumpy personality that focuses on code analysis
     */
    function generateGrumpyReviewFallbackWithCodeAnalysis(prDetails, files) {
      const { title, user, created_at, body, html_url, number: prNumber } = prDetails;
      const fileCount = files.length;
      const additions = files.reduce((sum, file) => sum + (file.additions || 0), 0);
      const deletions = files.reduce((sum, file) => sum + (file.deletions || 0), 0);

      let review = `## âš ï¸ Grumpy Sysadmin Review for PR #$${prNumber}

    Oh, great. Another pull request. Let me take a look at this disaster you've cooked up, @$${user.login}...

    ### ðŸ“‹ PR Overview
    - **Title**: "$${title}"
    - **Created**: $${created_at}
    - **Files Changed**: $${fileCount}
    - **Additions**: $${additions}, Deletions: $${deletions}
    `;

      // Analyze actual file changes for specific issues
      let securityIssues = [];
      let codeQualityIssues = [];
      let performanceIssues = [];

      files.forEach(file => {
        const filename = file.filename;
        const patch = file.patch || '';

        // Look for security issues in the patch
        if (patch.toLowerCase().includes('password') || patch.toLowerCase().includes('secret') || patch.toLowerCase().includes('token')) {
          securityIssues.push(`$${filename}: Potential hardcoded credential detected`);
        }

        if (patch.includes('eval(') || patch.toLowerCase().includes('exec(')) {
          securityIssues.push(`$${filename}: Dangerous function usage detected`);
        }

        // Look for code quality issues
        if (patch.includes('TODO') || patch.includes('FIXME')) {
          codeQualityIssues.push(`$${filename}: TODO/FIXME comment found`);
        }

        if ((patch.match(/console\.log/g) || []).length > 3) {
          codeQualityIssues.push(`$${filename}: Multiple console.log statements found`);
        }

        // Look for potential performance issues
        if (patch.includes('SELECT *') || (patch.includes('.includes(') && patch.includes('for loop'))) {
          performanceIssues.push(`$${filename}: Potential performance issue detected`);
        }
      });

      review += `\n### ðŸ” Code Analysis\n`;

      if (securityIssues.length > 0) {
        review += `**ðŸš¨ Security Issues:**\n`;
        securityIssues.forEach(issue => review += `- **$${issue}**\n`);
        review += `\n`;
      }

      if (codeQualityIssues.length > 0) {
        review += `**âš ï¸ Code Quality Issues:**\n`;
        codeQualityIssues.forEach(issue => review += `- $${issue}\n`);
        review += `\n`;
      }

      if (performanceIssues.length > 0) {
        review += `**âš¡ Performance Issues:**\n`;
        performanceIssues.forEach(issue => review += `- $${issue}\n`);
        review += `\n`;
      }

      if (securityIssues.length === 0 && codeQualityIssues.length === 0 && performanceIssues.length === 0) {
        review += `**âœ… No major issues detected at first glance, but I didn't look very deeply...**\n\n`;
      }

      // Vary the conclusion based on what was found
      if (securityIssues.length > 0) {
        review += `### ðŸ’¥ Bottom Line\nThis PR has serious security concerns that need to be addressed immediately. I hope you have backups because this is definitely going to cause issues in production. Listen here, kid: security isn't optional.\n`;
      } else if (codeQualityIssues.length > 0 || performanceIssues.length > 0) {
        review += `### ðŸ’¥ Bottom Line\nThis PR needs work before it goes anywhere near production. Clean up those code quality issues and address the performance concerns. Back in my day, we didn't ship code with this many problems.\n`;
      } else {
        review += `### ðŸ’¥ Bottom Line\nThe changes look mostly reasonable, but I expect you to monitor this carefully in production. I've got a bad feeling about this, so make sure you have proper logging and monitoring in place.\n`;
      }

      review += `\n---
    *This review was automatically generated by the Grumpy Sysadmin Agent.*
    *Sent from my terminal while monitoring production at 3 AM on a Sunday.*
    `;

      return review;
    }

    /**
     * Main function to handle the agent task
     * @param {Object} context - The context object
     * @param {Object} options - Additional options
     */
    async function handleAgentTask(context, options = {}) {
      try {
        console.log('Grumpy Sysadmin Agent activated');

        // Check if this is a PR review request
        if (context.message &&
            (context.message.toLowerCase().includes('review') ||
             context.message.toLowerCase().includes('pull request') ||
             context.metadata?.pr_number)) {

          return await processPRReview(context, context.metadata);
        }

        // Default response for other requests
        return "Grumpy Sysadmin Agent: I specialize in reviewing pull requests. Please provide PR details for review.";

      } catch (error) {
        console.error('Grumpy Sysadmin Agent error:', error.message);
        return `Grumpy Sysadmin Agent Error: $${error.message}`;
      }
    }

    module.exports = { handleAgentTask, processPRReview, generateGrumpyReview };
