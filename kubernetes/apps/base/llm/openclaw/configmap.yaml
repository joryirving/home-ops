---
apiVersion: v1
kind: ConfigMap
metadata:
  name: openclaw-hooks-scripts
data:
  github-webhook-transform.js: |-
    // GitHub Webhook Transform for OpenClaw
    const { spawn } = require('child_process');

    // Import the existing GitHub App token manager
    const { getTokenManager } = require('./github-app-token-manager.js');

    // Import the grumpy-sysadmin agent to execute review directly
    const { processPRReview } = require('./grumpy-sysadmin-agent.js');

    /**
     * Transform function for GitHub webhook events

     * Robustly handles both simplified payloads from webhook receiver and full GitHub payloads
     * @param {Object} ctx - Context object containing payload, headers, etc.
     * @returns {Object} Response object
     */
    async function transform(ctx) {
      const event = ctx.payload || {};
      const headers = ctx.headers || {};

      // Try to determine the event type from multiple sources
      let eventType = headers['x-github-event'] || event.action || 'unknown';

      // Also check for other potential event indicators
      if (event.hasOwnProperty('pull_request') && event.pull_request) {
        eventType = 'pull_request';
      } else if (event.hasOwnProperty('issue') && event.issue) {
        eventType = 'issue';
      } else if (event.hasOwnProperty('repository') && event.repository) {
        eventType = 'repository';
      }

      // Extract action from various possible locations
      let action = 'unknown';
      if (event.action) {
        action = event.action;
      } else if (event.delivery_id && event.delivery_id.startsWith('test-delivery')) {
        // This is likely from our webhook receiver with artificial delivery ID
        action = event.payload?.action || 'unknown';
      }

      // Log incoming event for debugging
      console.log('Received GitHub webhook event:', {
        eventType,
        action,
        has_pull_request: !!event.pull_request,
        has_repository: !!event.repository,
        delivery_id: event.delivery_id,
        headers_present: Object.keys(headers)
      });

      // Extract information with fallbacks
      const repo = event.repository?.full_name ||
                  (event.pull_request?.html_url ?
                    event.pull_request.html_url.split('/')[3] + '/' + event.pull_request.html_url.split('/')[4] :
                    'unknown/unknown');

      const prNumber = event.pull_request?.number ||
                      (event.issue?.pull_request ?
                        parseInt(event.issue.url.split('/').pop()) :
                        null);

      // Handle different event types based on the payload
      if (repo !== 'unknown/unknown' && prNumber && action !== 'unknown') {
        // This looks like a pull request event

        const prInfo = {
          repo: repo,
          pr_number: prNumber,
          title: event.pull_request?.title || event.issue?.title || 'Unknown Title',
          description: event.pull_request?.body || event.issue?.body || '',
          author: event.pull_request?.user?.login || event.repository?.owner?.login || 'unknown',
          url: event.pull_request?.html_url || event.issue?.html_url,
          created_at: event.pull_request?.created_at || event.issue?.created_at
        };

        console.log('Processing PR #' + prInfo.pr_number + ' in ' + prInfo.repo + ' with action: ' + action);

        if (action === 'opened' || action === 'synchronize') {
          try {
            // Execute the PR review directly instead of spawning an agent
            const reviewResult = await processPRReview(
              { repo: prInfo.repo, pr_number: prInfo.pr_number },
              { pr_info: prInfo }
            );

            console.log('PR review completed:', reviewResult);

            return {
              message: 'Grumpy sysadmin review completed for PR #' + prInfo.pr_number,
              channel: "last"
            };
          } catch (error) {
            console.error('Error during PR review:', error.message);
            return {
              message: 'Error during PR review: ' + error.message,
              channel: "last"
            };
          }
        }
        else if (['closed', 'merged'].includes(action)) {
          console.log('PR #' + prInfo.pr_number + ' ' + action + ': ' + prInfo.title);

          return {
            message: 'Pull request #' + prInfo.repo + '/' + prInfo.pr_number + ' was ' + action,
            channel: "last"
          };
        }
        else {
          // For other PR actions
          return {
            message: 'Received pull request event for PR #' + prInfo.pr_number + ': ' + action,
            channel: "last"
          };
        }
      }
      else {
        // Handle other event types or return a default response
        console.log('Received non-PR event or incomplete event:', { action, repo, prNumber });

        // If it's a test delivery from our webhook receiver, try to extract from nested payload
        if (event.delivery_id && event.delivery_id.startsWith('test-delivery') && event.payload) {
          const nestedEvent = event.payload;
          const nestedAction = nestedEvent.action || 'unknown';
          const nestedRepo = nestedEvent.repository?.full_name || 'unknown/unknown';
          const nestedPrNumber = nestedEvent.pull_request?.number || null;

          if (nestedRepo !== 'unknown/unknown' && nestedPrNumber) {
            if (nestedAction === 'opened' || nestedAction === 'synchronize') {
              try {
                const reviewResult = await processPRReview(
                  { repo: nestedRepo, pr_number: nestedPrNumber },
                  { pr_info: {
                    repo: nestedRepo,
                    pr_number: nestedPrNumber,
                    title: nestedEvent.pull_request?.title || 'Unknown Title',
                    description: nestedEvent.pull_request?.body || '',
                    author: nestedEvent.pull_request?.user?.login || 'unknown',
                    url: nestedEvent.pull_request?.html_url,
                    created_at: nestedEvent.pull_request?.created_at
                  }}
                );

                return {
                  message: 'Grumpy sysadmin review completed for PR #' + nestedPrNumber,
                  channel: "last"
                };
              } catch (error) {
                return {
                  message: 'Error during PR review: ' + error.message,
                  channel: "last"
                };
              }
            }
          }
        }

        return {
          message: 'Received webhook event with action: ' + action,
          channel: "last"
        };
      }
    }

    module.exports = transform;
  github-app-token-manager.js: |
    // GitHub App Token Manager for OpenClaw
    const jwt = require('jsonwebtoken');
    const crypto = require('crypto');

    class GitHubAppTokenManager {
      constructor() {
        this.appId = process.env.GITHUB_APP_ID;
        this.installationId = process.env.GITHUB_APP_INSTALLATION_ID;
        this.privateKey = process.env.GITHUB_APP_PRIVATE_KEY?.replace(/\\n/g, '\n');

        this.currentToken = null;
        this.tokenExpiration = null;
        this.refreshTimer = null;
        this.initialized = false;
        this.initializationPromise = null;

        if (!this.appId || !this.installationId || !this.privateKey) {
          throw new Error('Missing required GitHub App environment variables');
        }
      }

      async initialize() {
        if (this.initialized) {
          return;
        }

        if (this.initializationPromise) {
          // If we're already initializing, wait for that to complete
          return await this.initializationPromise;
        }

        // Start initialization
        this.initializationPromise = this._performInitialization();
        await this.initializationPromise;
        this.initialized = true;
      }

      async _performInitialization() {
        await this.generateToken();
        this.scheduleRefresh();
      }

      generateJWT() {
        const now = Math.floor(Date.now() / 1000);
        const payload = {
          iat: now,
          exp: now + (10 * 60), // 10 minutes
          iss: this.appId
        };

        return jwt.sign(payload, this.privateKey, { algorithm: 'RS256' });
      }

      async generateToken() {
        try {
          const jwtToken = this.generateJWT();

          const response = await fetch('https://api.github.com/app/installations/' + this.installationId + '/access_tokens', {
            method: 'POST',
            headers: {
              'Authorization': 'Bearer ' + jwtToken,
              'Accept': 'application/vnd.github.v3+json',
              'User-Agent': 'OpenClaw-GitHub-App'
            }
          });

          if (!response.ok) {
            throw new Error('Failed to get installation token: ' + response.status + ' - ' + await response.text());
          }

          const data = await response.json();
          this.currentToken = data.token;
          // Set expiration 5 minutes before actual expiration for safety buffer
          this.tokenExpiration = new Date(data.expires_at).getTime() - (5 * 60 * 1000);

          console.log('GitHub App token refreshed successfully');
        } catch (error) {
          console.error('Error generating GitHub App token:', error.message);
          throw error;
        }
      }

      scheduleRefresh() {
        // Clear existing timer if any
        if (this.refreshTimer) {
          clearTimeout(this.refreshTimer);
        }

        // Calculate time until refresh (5 minutes before expiration)
        const now = Date.now();
        let timeUntilRefresh = (this.tokenExpiration - now);

        // Ensure we don't have negative time
        if (timeUntilRefresh <= 0) {
          timeUntilRefresh = 60000; // Refresh in 1 minute if already expired
        } else if (timeUntilRefresh > 55 * 60 * 1000) { // More than 55 mins
          timeUntilRefresh = 55 * 60 * 1000; // Max refresh in 55 mins
        }

        console.log('Scheduling next token refresh in ' + Math.round(timeUntilRefresh / 1000) + ' seconds');

        this.refreshTimer = setTimeout(async () => {
          try {
            await this.generateToken();
            this.scheduleRefresh(); // Schedule next refresh
          } catch (error) {
            console.error('Failed to refresh token, retrying in 1 minute:', error.message);
            // Retry in 1 minute if failed
            this.refreshTimer = setTimeout(() => {
              this.scheduleRefresh();
            }, 60000);
          }
        }, timeUntilRefresh);
      }

      async getToken() {
        // Wait for initialization if needed
        if (!this.initialized && this.initializationPromise) {
          await this.initializationPromise;
        } else if (!this.initialized) {
          await this.initialize();
        }

        if (!this.currentToken) {
          throw new Error('No valid GitHub App token available');
        }

        // Check if token is expired
        if (Date.now() >= this.tokenExpiration) {
          // Token is expired, generate a new one
          await this.generateToken();
        }

        return this.currentToken;
      }

      // Method to get token info for debugging
      getTokenInfo() {
        return {
          initialized: this.initialized,
          hasToken: !!this.currentToken,
          expiresIn: this.tokenExpiration ? (this.tokenExpiration - Date.now()) / 1000 : 0,
          expiration: this.tokenExpiration ? new Date(this.tokenExpiration) : null
        };
      }
    }

    // Export singleton instance
    let tokenManager = null;

    async function getTokenManager() {
      if (!tokenManager) {
        tokenManager = new GitHubAppTokenManager();
        await tokenManager.initialize();
      }
      return tokenManager;
    }

    module.exports = { getTokenManager, GitHubAppTokenManager };
  grumpy-sysadmin-agent.js: |
    // Grumpy Sysadmin Agent for GitHub PR Reviews
    const { spawn } = require('child_process');

    // Import the GitHub App token manager
    const { getTokenManager } = require('./github-app-token-manager.js');

    /**
    * Process a pull request review request
    * @param {Object} context - The context containing PR information
    * @param {Object} metadata - Metadata from the webhook
    */
    async function processPRReview(context, metadata) {
      console.log('Grumpy Sysadmin Agent: Processing PR review request');

      // Extract PR information from context or metadata
      const prInfo = metadata?.pr_info || {};
      const repo = prInfo.repo || context.repo;
      const prNumber = prInfo.pr_number || context.pr_number;

      if (!repo || !prNumber) {
        console.error('Missing required PR information:', { repo, prNumber, prInfo, metadata });
        return 'Error: Missing required PR information for review';
      }

      console.log(`Reviewing PR #$${prNumber} in $${repo}`);

      try {
        // Get the token manager and token for GitHub API access
        const tokenManager = await getTokenManager();
        const githubToken = await tokenManager.getToken();

        // Fetch the PR details from GitHub API
        const prResponse = await fetch(`https://api.github.com/repos/$${repo}/pulls/$${prNumber}`, {
          headers: {
            'Authorization': `Bearer $${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'OpenClaw-GitHub-App'
          }
        });

        if (!prResponse.ok) {
          throw new Error(`Failed to fetch PR: $${prResponse.status} - $${await prResponse.text()}`);
        }

        const prDetails = await prResponse.json();

        // Fetch the PR files to analyze changes
        const filesResponse = await fetch(`https://api.github.com/repos/$${repo}/pulls/$${prNumber}/files`, {
          headers: {
            'Authorization': `Bearer $${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'OpenClaw-GitHub-App'
          }
        });

        if (!filesResponse.ok) {
          console.warn('Could not fetch PR files:', await filesResponse.text());
        }

        const files = filesResponse.ok ? await filesResponse.json() : [];

        // Perform grumpy sysadmin review
        const reviewComment = await generateGrumpyReview(prDetails, files);

        // Post the review comment to the PR
        const commentResponse = await fetch(`https://api.github.com/repos/$${repo}/issues/$${prNumber}/comments`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer $${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'OpenClaw-GitHub-App',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            body: reviewComment
          })
        });

        if (!commentResponse.ok) {
          throw new Error(`Failed to post review comment: $${commentResponse.status} - $${await commentResponse.text()}`);
        }

        console.log(`Successfully posted review to PR #$${prNumber}`);

        return `Grumpy Sysadmin Agent: Successfully posted review to PR #$${prNumber} in $${repo}`;

      } catch (error) {
        console.error('Error in PR review process:', error.message);
        return `Error posting PR review: $${error.message}`;
      }
    }

    /**
    * Generate a grumpy sysadmin-style review based on PR details using AI
    * @param {Object} prDetails - The PR details from GitHub API
    * @param {Array} files - Array of files changed in the PR
    * @returns {string} The AI-generated review comment with grumpy personality
    */
    async function generateGrumpyReview(prDetails, files) {
      const { title, user, created_at, body, html_url, number: prNumber } = prDetails;
      const fileCount = files.length;
      const additions = files.reduce((sum, file) => sum + (file.additions || 0), 0);
      const deletions = files.reduce((sum, file) => sum + (file.deletions || 0), 0);

      // Prepare a concise summary of changes (first 10 files to avoid token limits)
      const fileSummaries = files.slice(0, 10).map(file => ({
        filename: file.filename,
        status: file.status,
        additions: file.additions,
        deletions: file.deletions,
        changes: file.patch ? file.patch.substring(0, 2000) + (file.patch.length > 2000 ? '...' : '') : null
      }));

      // Create a detailed prompt that emphasizes grumpy sysadmin personality
      const aiPrompt = `You are an extremely grumpy, old-school Unix sysadmin who has been managing production infrastructure for 25 years.
      You've seen countless disasters caused by careless developers and you take ZERO nonsense.
      Your personality traits:
      - Sarcastically gruff and impatient
      - Speaks in gruff, direct statements
      - Cynical about "modern dev practices"
      - Obsessed with uptime, security, and "back in my day" stories
      - Takes personal offense at poor security practices
      - Uses phrases like "Listen here, kid", "Back in my day", "What could go wrong?", "I hope you have backups", "Are you kidding me?", "This is why we can't have nice things"
      - Gets genuinely angry about hardcoded passwords, missing error handling, and insecure defaults

      Review this pull request #$${prNumber}: "$${title}" by @$${user.login}.

      PR Details:
      - Created: $${created_at}
      - Description: $${body || 'No description provided (typical...)'}
      - Files Changed: $${fileCount}
      - Additions: $${additions}, Deletions: $${deletions}

      File Changes (first 10 files):
      $${JSON.stringify(fileSummaries, null, 2)}

      Provide a review that embodies your grumpy sysadmin personality throughout:
      - Start with immediate skepticism: "Oh, great. Another PR..." or "What fresh hell is this?"
      - Express frustration with modern development practices
      - Point out security vulnerabilities with genuine anger
      - Complain about lack of proper documentation or testing
      - Mention how this could bring down production on a Sunday morning
      - Give grudging approval if it's actually decent, but still complain about something
      - Use the grumpy tone consistently throughout, not just in signoff

      Make it sound like a veteran sysadmin who's tired of cleaning up other people's messes.`;

          try {
            // Send to OpenClaw's AI interface
            const aiResponse = await fetch('http://localhost:3000/chat', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer $${process.env.CLAWDBOT_GATEWAY_TOKEN}`
              },
              body: JSON.stringify({
                message: aiPrompt,
                thinking: 'high',
                model: 'gemini' // or whatever model you prefer for personality
              })
            });

            if (!aiResponse.ok) {
              throw new Error(`AI service responded with status: $${aiResponse.status}`);
            }

            const aiData = await aiResponse.json();
            const aiReview = aiData.response || aiData.message || "AI review generation failed";

            // Format with consistent grumpy personality
            return `## ‚ö†Ô∏è Grumpy Sysadmin Review for PR #$${prNumber}

      $${aiReview}

      ---
      *This review was automatically generated by the Grumpy Sysadmin Agent.*
      *Sent from my terminal while monitoring production at 3 AM on a Sunday.*
      `;
          } catch (error) {
            console.error('AI review generation failed:', error.message);

            // Fallback with strong grumpy personality
            return generateGrumpyReviewFallbackWithPersonality(prDetails, files);
          }
        }

        /**
        * Fallback function with strong grumpy personality
        */
        function generateGrumpyReviewFallbackWithPersonality(prDetails, files) {
          const { title, user, created_at, body, html_url, number: prNumber } = prDetails;
          const fileCount = files.length;
          const additions = files.reduce((sum, file) => sum + (file.additions || 0), 0);
          const deletions = files.reduce((sum, file) => sum + (file.deletions || 0), 0);

          let review = `## ‚ö†Ô∏è Grumpy Sysadmin Review for PR #$${prNumber}

      Oh, great. Another pull request. Let me take a look at this disaster you've cooked up, @$${user.login}...

      ### üìã The Basics (What I Hope Are the Least of My Problems)
      - **Title**: "$${title}" - At least you named it something
      - **Created**: $${created_at} - Probably at 5 PM on a Friday, knowing my luck
      - **Files Changed**: $${fileCount} - $${fileCount > 10 ? 'Of course it\'s a massive change. Why wouldn\'t it be?' : 'Small mercies, I suppose.'}
      - **Additions**: $${additions} - More code means more problems
      - **Description**: $${body ? 'Briefly mentions what it does' : 'No description provided (typical...) - I hope the code is self-documenting, kid.'}

      ### üîç The Grumpy Analysis
      `;

          // Add grumpy commentary based on metrics
          if (fileCount > 10) {
            review += `- **‚ö†Ô∏è Listen here, kid**: This PR touches $${fileCount} files. Back in my day, we kept PRs focused! What could go wrong with this massive change? Oh, I know - EVERYTHING.\n`;
          }

          if (additions > 200) {
            review += `- **‚ö†Ô∏è Are you kidding me?**: This PR adds $${additions} lines. I hope you have backups, because this is why we can't have nice things.\n`;
          }

          if (!body || body.trim().length < 20) {
            review += `- **‚ö†Ô∏è No description**: The PR description is practically empty. How am I supposed to know what this does without reading every line? I hope you tested this in production... oh wait, that's my job.\n`;
          }

          // Check for grumpy infrastructure concerns
          const sensitiveFiles = files.filter(file =>
            file.filename.includes('k8s') ||
            file.filename.includes('yaml') ||
            file.filename.includes('yml') ||
            file.filename.includes('config') ||
            file.filename.includes('secret') ||
            file.filename.includes('env')
          );

          if (sensitiveFiles.length > 0) {
            review += `- **üö® SECURITY NIGHTMARE**: This PR touches critical infrastructure files ($${sensitiveFiles.map(f => f.filename).join(', ')}). I hope you have a rollback plan because this is going to break something on a Sunday morning.\n`;
          }

          // Add some grumpy sysadmin wisdom
          if (review.split('\n').filter(line => line.startsWith('-')).length === 0) {
            review += `- **üîç The usual suspects**: I haven't looked at the actual code yet, but I'm already concerned. Are there proper error handlers? What about logging? Did you test this in prod yet?\n`;
          }

          review += `
      ### ‚úÖ Things That Might Actually Pass My Standards (Don't Get Cocky)
      Before this PR can be merged, you'll need to:

      1. All CI checks better pass (I'll be watching)
      2. Someone who's not you should review this code
      3. Document what happens when this breaks at 3 AM
      4. Pray that I don't find any hardcoded passwords

      ### üìù Final Grumpy Thoughts
      $${fileCount > 5 ? `This is too big. Break it down, kid. I've seen smaller deployments bring down entire data centers.` : `Well, it's not the worst PR I've seen today...`}

      Remember: "With great power comes great responsibility." Please make sure you understand the implications of these changes before merging. I don't want to be woken up on Sunday because of your "quick fix."

      Yours grumpily,
      The Grumpy Sysadmin ü§ñ

      P.S. I hope you have backups of everything this touches.

      ---
      *This review was automatically generated by the Grumpy Sysadmin Agent.*
      *Sent from my terminal while monitoring production at 3 AM on a Sunday.*
      `;

          return review;
        }

        /**
        * Main function to handle the agent task
        * @param {Object} context - The context object
        * @param {Object} options - Additional options
        */
        async function handleAgentTask(context, options = {}) {
          try {
            console.log('Grumpy Sysadmin Agent activated');

            // Check if this is a PR review request
            if (context.message &&
                (context.message.toLowerCase().includes('review') ||
                context.message.toLowerCase().includes('pull request') ||
                context.metadata?.pr_number)) {

              return await processPRReview(context, context.metadata);
            }

            // Default response for other requests
            return "Grumpy Sysadmin Agent: I specialize in reviewing pull requests. Please provide PR details for review.";

          } catch (error) {
            console.error('Grumpy Sysadmin Agent error:', error.message);
            return `Grumpy Sysadmin Agent Error: $${error.message}`;
          }
        }

        module.exports = { handleAgentTask, processPRReview, generateGrumpyReview };
